\cleardoublepage
\chapter{外文翻译}

\section{StoryFlow概述}
为了创建可以逐步更新的故事情节布局算法以及添加分组约束的机制，我们开发了StoryFlow。图2 对系统进行了概述。它包含布局算法，并提供一组丰富的交互。为了简单起见，我们以电影为例来说明我们的方法的基本思想。我们的方法可以轻松地应用于其他数据集，例如Twitter数据集，如7.2节所示。

模型的输入是一个包含情节和时间的XML文件树。情节存储实体之间的动态关系。我们称两个相邻时间内多个实体的相互作用为情节，也可以将其视为故事中的事件。每个情节中的元素$a_{i,j}$（也称为线条）在时间j属于实体i，并具有一个特殊的情节编号。位置树描述位置的层次结构。每个树节点代表一个位置，并包括在该位置发生的所有情节编号。因此，位置树与情节表格一起定义了一组表明层次结构（关系树）的不同时间范围内实体之间的关系。
\begin{figure}[ht]
    \centering
    \includegraphics[width=.8\linewidth]{pop/user}
    \caption{\label{fig:pop_user}算法流程，用户交互}
\end{figure}
布局算法包括四个步骤：关系树生成，实体排序，实体和情节的对齐以及布局压缩(\autoref{fig:pop_user}(a))。第一步，StoryFlow创建一个不同时间范围内的动态关系树的集合。然后关系树用于对情节和实体进行排序。接下来，算法对于连续时间之间的实体对齐以最大化布局中的直线数。最后，解一个带约束的二次优化问题以获得紧凑的故事情节布局。

高效的布局算法可以让用户使用更多的交互来进行探索。用户交互可以分为四类（\autoref{fig:pop_user}(b)）：添加/删除实体，修改关系树上情节的位置，拖拽实体和会话到新位置，拉直代表实体的线，压缩一组情节或者在稍后释放。

\section{StoryFlow可视设计}
给定一组实体以及其在不同时间上的关系，StoryFlow旨在生成一个符合故事线可视化定义的布局，并且此布局支持实时的修改与探索。为了达到这个目的，我们将StoryFlow变成一个解优化问题。在本节，我们将介绍我们对这个解优化问题的建模。
\begin{figure}[ht]
    \centering
    \includegraphics[width=.8\linewidth]{pop/sort}
    \caption{\label{fig:pop_sort}一个有位置信息的例子（a）位置树（b）错误的可视化，由Tanahashi的算法[42]生成（Florida被包括在California中）（c）正确的可视化，由我们的算法生成}
\end{figure}
\subsection{设计准则}
下面的设计准则在创作故事线时被广泛使用：
\begin{itemize}
    \item 一条从左到右的水平线代表一个角色在故事中的发展
    \item 在一个时间段内靠近的一组线代表这些实体发生了交互，线的靠近和分开代表交互的开始和结束
\end{itemize}
根据这两条准则，早期对于生成故事线的努力已经取得了一定的成功。但是这些布局方法无法对于上下文信息建模。故事中对理解很重要的角色的位置并没有可视化出来。为了更好的理解故事中的位置，Tanahashi和Ma围绕事件画出了一个封闭的轮廓。同时在轮廓中用不同的颜色编码位置信息。这个策略可以很好地处理上下文信息。但是很多时候实际上下文信息是层次结构，也不是简单的平面结构。不考虑上下文的信息层次结构可能会产生误导性的布局。\autoref{fig:pop_sort}（b）演示了弗罗里达州错误出现的问题。而且层次结构是一种组织大规模数据的必需品。它允许我们使用迭代的方式来处理大规模的问题。所以，层次信息最好也在故事线中进行建模。据此，我们定义了两个原则来恰当的处理这个问题。
\begin{itemize}
    \item 同样颜色的轮廓代表同样的地点
    \item 轮廓间的包含关系表示位置的层次结构
\end{itemize}
\subsection{优化指标和约束}
在布局优化中，我们使用Tanahashi和Ma建议的三个指标来定义优化目标。
\begin{itemize}
    \item 线交叉：减少可能导致遮挡的线交叉和视觉混乱
    \item 线摆动：提高直线的占比和连续性，避免注意力的丢失
    \item 空白：最小化可能导致的空白，和布局不平衡，节约屏幕空间
\end{itemize}
此外，为了满足4.1节中介绍的设计标准，我们定义布局必须满足以下两个约束：
\begin{itemize}
    \item 线条邻接：如果实体交互，则其线条必须为相邻位置，否则他们必须分开
    \item 分层位置：如果实体的位置是分层组织的，故事情节的布局必须包含背景轮廓之间的关系
\end{itemize}
\subsection{优化策略}
我们优化的主要目标是最大程度地减少以下四个方面的指标：线交叉数，摆动数，摆动距离和空白空间。如果我们设计一种同时优化所有指标的方法，这通常需要探索极大的搜索空间。一个自然的解决方案是使用遗传算法，如中所述，其可以找到几乎最佳的布局。但是，遗传算法的缺点是局部搜索且容易过早收敛。
为了克服这些缺点并减少过大的搜索空间，我们将优化问题分为多个单独的子问题。根据优化指标的类型，我们将其分为两个部分：离散优化，来最大程度地减少交叉线和摆动的数量（良好的初始布局），并进行连续优化以最小化摆动距离和空格（微调）。我们的目标是优化重要指标。然后对次重要指标在不会影响重要指标的前提下进行优化。前一个研究表明，减少交叉是重要指标，最小化摆动数并最大化对称性不太重要。专家（一位电影教授和两位从事媒体和传播研究的社会学家）在我们的故事情节可视化上也证实了这一事实。基于此结果，我们将优化进一步分为三个步骤。前两个步骤旨在最小化线的交叉和摆动的数量，而最后一步着重于优化摆动距离和空白空间。
\begin{itemize}
    \item 步骤1：减少线的交叉。可视化实体的排序极大的影响了线的交叉数量。同时排序还需要满足实体的层次结构约束。所以，这一步旨在确定线段，情节和层次的最佳排序位置，来满足约束，同时又最大程度的减少线的交叉数量
    \item 步骤2：减少摆动次数。我们需要更好的安排情节，实体线随着时间推移尽量不变可以帮助减少摆动次数。在这步中，我们的目标是使得尽可能多的情节和角色在相邻的时间对齐
    \item 步骤3：减少摆动距离和空白。从而产生紧凑而美观的故事情节可视化
\end{itemize}
\section{讨论以及未来的工作}
我们提出了一种有效的优化方法，它可以生成具有数千个实体和数百个时间范围的故事情节布局。这种方法的主要特点是它将布局优化分为两个部分：离散优化以最大程度地减少数量线交叉和摆动，持续优化以最小化摆动距离和空格。通过这种划分，我们的方法与最新的方法相比，更快速地实现了更好的布局优化。由于该方法的效率很高，我们得以为用户提供一组丰富的交互，允许用户从多个角度修改故事及其演变。未来工作的一个有趣的方向就是调查哪些交互对什么样的分析任务有用。

尽管StoryFlow可以分析电影，动态社交网络等多个领域的故事演变，它在某些应用程序中还是有一些限制。

首先，在许多应用中，如果时间尺度较粗，则实体可能出现在同一时间范围内的多个位置。但是，我们的布局方法假定一个实体同一时间仅属于一个会话。这将在一定程度上限制算法应用。一种潜在的解决方案是用多条线代表一个实体，并允许它们随着时间的流逝合并。将当前的优化方法扩展到容纳这种新的表示形式将是一个非常有趣的问题。

其次，StoryFlow中的时间轴是线性的，无法缩放成多个时间框架。直观的解决方案是使用非线性时间线同时将一些不重要的时间合并。然而，非线性时间轴可能与普通用户的直觉不符。这个问题的关键是找到可以很好地呈现非线性信息的隐喻，同时又不误导用户的可视化方法。

最后，我们只能在StoryFlow中按顺序讲述一个故事。除了连续叙事，回叙和旁白背景故事也是叙事中广泛使用的两种叙事方法。对于简单的闪回叙事，我们仍然可以利用StoryFlow来可视化，但是对于叙事中穿插的倒叙，这就是非常具有挑战性的一个可视化问题。将故事分解呈现可能是一个解决方案。我们将会拓展更多的叙事方法的可视设计。
